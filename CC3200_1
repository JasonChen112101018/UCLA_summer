#ifndef __CC3200R1M1RGC__ 
#include <SPI.h>
#endif
#include <WiFi.h>

// LED 腳位定義，請依實際腳位修改
#define RED_LED    9
#define ORANGE_LED 10
#define GREEN_LED  11

const char ssid[] = "MyEnergiaAP";
const char password[] = "password";

WiFiServer tcpServer(8080);
WiFiClient tcpClient;

#define STX 0x02
#define ETX 0x03

String uartBuffer = "";
bool receivingUART = false;

String tcpBuffer = "";
bool receivingTCP = false;

unsigned int num_clients = 0;
int currentLED = 0;      // 控制閃爍 LED
unsigned long lastBlinkTime = 0;  // 上次切換LED時間
const unsigned long blinkInterval = 500;  // 閃爍間隔 (毫秒)

void setup() {
  Serial.begin(115200);

  pinMode(RED_LED, OUTPUT);
  pinMode(ORANGE_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);

  // 初始都關閉
  digitalWrite(RED_LED, LOW);
  digitalWrite(ORANGE_LED, LOW);
  digitalWrite(GREEN_LED, LOW);

  Serial.print("Setting up Access Point named: ");
  Serial.println(ssid);
  Serial.print("AP uses WPA and password is: ");
  Serial.println(password);

  WiFi.beginNetwork((char *)ssid, (char *)password);

  while (WiFi.localIP() == INADDR_NONE) {
    Serial.print('.');
    delay(300);
  }
  Serial.println();
  Serial.print("AP active. IP: ");
  Serial.println(WiFi.localIP());

  tcpServer.begin();
  Serial.println("TCP Server started on port 8080");
}

void loop() {
  // 更新目前連線數
  num_clients = WiFi.getTotalDevices();

  // 若有連線，進行 LED 交替閃爍
  if (num_clients >= 1) {
    unsigned long now = millis();
    if (now - lastBlinkTime > blinkInterval) {
      lastBlinkTime = now;

      // 關閉全部 LED
      digitalWrite(RED_LED, LOW);
      digitalWrite(ORANGE_LED, LOW);
      digitalWrite(GREEN_LED, LOW);

      // 開啟下一顆 LED
      currentLED = (currentLED + 1) % 3;
      switch (currentLED) {
        case 0: digitalWrite(RED_LED, HIGH); break;
        case 1: digitalWrite(ORANGE_LED, HIGH); break;
        case 2: digitalWrite(GREEN_LED, HIGH); break;
      }
    }
  } else {
    // 無連線，全部 LED 關閉
    digitalWrite(RED_LED, LOW);
    digitalWrite(ORANGE_LED, LOW);
    digitalWrite(GREEN_LED, LOW);
  }

  // 處理 TCP 新連線
  WiFiClient newClient = tcpServer.available();
  if (newClient && (!tcpClient || !tcpClient.connected())) {
    tcpClient = newClient;
    Serial.println("TCP client changed");
  }


  // --- [1] 接收 TCP 指令 → 傳給 F2837x via UART
  if (tcpClient && tcpClient.connected()) {
    while (tcpClient.available()) {
      char ch = tcpClient.read();

      if (ch == STX) {
        receivingTCP = true;
        tcpBuffer = "";
      } else if (ch == ETX && receivingTCP) {
        receivingTCP = false;
        Serial.print("TCP->UART: ");
        Serial.println(tcpBuffer);
        sendToC2000(tcpBuffer);
      } else if (receivingTCP) {
        tcpBuffer += ch;
      }
    }
  }

  // --- [2] 接收 F2837x 感測資料 → 傳給 TCP 用戶端
  while (Serial.available()) {
    char ch = Serial.read();

    if (ch == STX) {
      receivingUART = true;
      uartBuffer = "";
    } else if (ch == ETX && receivingUART) {
      receivingUART = false;
      Serial.print("UART->TCP: ");
      Serial.println(uartBuffer);
      sendToTCPClient(uartBuffer);
    } else if (receivingUART) {
      uartBuffer += ch;
    }
  }

  delay(10);
}

void sendToC2000(String msg) {
  Serial.write(STX);
  Serial.print(msg);
  Serial.write(ETX);
}

void sendToTCPClient(String msg) {
  if (tcpClient && tcpClient.connected()) {
    tcpClient.write(STX);
    tcpClient.print(msg);
    tcpClient.write(ETX);
  }
}
